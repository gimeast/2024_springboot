## 회원 도메인 설계

### 회원 도메인 요구사항
* 회원을 가입하고 조회할 수 있다.
* 회원은 일반과 VIP 두 가지 등급이 있다.
* 회원 데이터는 자체 DB를 구축할 수 잇고, 외부 시스템과 연동할 수 있다.(미확정)

`*회원 도메인 협력 관계*`

| 클라이언트 | 회원 서비스 | 회원 저장소 |
|----------|--------|-----------|
|          | 회원가입   | 메모리       |
|          | 회원조회   | DB        |
|          |        | 외부 시스템 연동 |



## 주문과 할인 도메인 설계

### 주문과 할인 정책
* 회원은 상품을 주문할 수 있다.
* 회원 등급에 따라 할인 정책을 적용할 수 있다.
* 할인 정책은 모든 VIP는 1000원 을 할인해주는 고정 금액 할인을 적용해달라.(나중에 변경될 수 있다.)
* 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을수도 있따.(미확정)

`*주문 도메인 협력, 역할, 책임`
1. 주문생성: 클라이언트는 주문 서비스에 주문 생성을 요청한다.
2. 회원조회: 할인을 위해서는 회원 등급이 필요하다. 그래서 주문 서비스는 회원 저장소에서 회원을 조회한다.
3. 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임한다.
4. 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다.



## 좋은 객체 지향 설계의 5가지 원칙의 적용
* 여기서 3가지 SRP, DIP, OCP 적용

### SRP 단일 책임 원칙
한 클래스는 하나의 책임만 가져야 한다.

* 이전에는 클라이언트 객체가 직접 구현 객체를 생성하고, 연결하고, 실행하는 다양한 책임을 가지고 있었다.
* SRP 단일 책임 원칙을 따르면서 관심사를 분리하였다.
* 구현 객체를 생성하고 연결하는 책임은 AppConfig가 담당하게 되었다.
* 클라이언트 객체는 실행하는 책임만 담당한다.

### DIP 의존관계 역전 원칙
프로그래머는 `추상화에 의존해야지 구체화에 의존하면 안된다.` 의존성 주입은 이 원칙을 따르는 방법 중 하나다.

### OCP
소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.


## IOC, DI 그리고 컨테이너

### 제어의 역전 IOC(Inversion of control)
* 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행했다. 
  한마디로 구현 객체가 프로그램의 제허 흐름을 스스로 조종했다. 개발자 입장에서는 자연스러운 흐름이다.
* 반면에 AppConfig가 등자한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 
  프로그램의 제어 흐름은 이제 AppConfig가 가져간다. 
  예를 들어 OrderServiceImpl은 필요한 인터페이스들을 호출하지만 어떤 구현 객체들이 실행될지 모른다.
* 이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전이라한다.

### 의존관계 주입 DI
* OrderServiceImpl은 DiscountPolicy 인터페이스에 의존한다. 실제 어떤 구현 객체가 사용될지는 모른다.
* 의존관계는 정적인 클래스 의존관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계 둘을 분리해서 생각해야 한다.
* 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 의존관계 주입이라 한다.
* 객체 인스턴스를 생성하고 그 참조값을 전달해서 연결된다.
* 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
* 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.


### IOC 컨테이너, DI 컨테이너
* AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을
  IOC 컨테이너 또는 DI 컨테이너라 한다.
* 의존관계 주입에 초점을 맞추어 최근에는 주로 **DI 컨테이너**라 한다.
* 또는 어셈블러, 오브젝트 팩토리 등으로 불리기도 한다.


### 스프링 컨테이너의 생성 과정
1. 스프링 컨테이너 생성
    * new AnnotationConfigApplicationContext(AppConfig.class)
    * 스프링 컨테이너를 생성할 때는 구성 정보를 지정해주어야 한다.
    * 여기서는 AppConfig.class를 구성 정보로 지정했다.
2. 스프링 빈 등록
    * 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈을 등록한다.
3. 스프링 빈 의존관계 설정 - 준비
4. 스프링 빈 의존관계 설정 - 완료


### 스프링 빈 조회 - 상속관계
* 부모 타입으로 조회하면 자식 타입도 함께 조회한다.
* 그래서 모든 자바 객체의 최고 부모인 Object 타입으로 조회하면 모든 스프링 빈을 조회한다.


### BeanFactory와 ApplicationContext
**BeanFactory**
* 스프링 컨테이너의 최상위 인터페이스다.
* 스프링 빈을 관리하고 조회하는 역할을 담당한다.
* getBean()을 제공한다.

**ApplicationContext**
* BeanFactory 기능을 모두 상속받아서 제공한다.
* 빈을 관리하고 검색하는 기능을 BeanFactory가 제고해주는데, 둘의 차이는???
* 애플리케이션을 개발할 때는 빈은 관리하고 조회하는 기능은 물론이고, 수 많은 부가기능이 필요하다.

ApplicationContext가 제공하는 부가기능
* BeanFactory :
* MessageSource : 메시지소르를 활용한 국제화 기능
  * 예를 들어서 한국에서 들어오면 한국어, 영어권에서 들어오면 영어로 출력
* EnvironmentCapable : 환경변수
  * 로컬, 개발, 운영등을 구분해서 처리
* ApplicationEventPublisher : 애플리케이션 이벤트
  * 이벤트를 발행하고 구독하는 모델을 편리하게 지원
* ResourceLoader : 편리한 리소스 조회
  * 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

**정리**
* ApplicationContext는 BeanFactory의 기능을 상속받는다.
* ApplicationContext는 빈 관리기능 + 편리한 부가 기능을 제공한다.
* BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용한다.
* BeanFactory나 ApplicationContext를 스프링 컨테이너라 한다.


## 스프링 빈 설정 메타 정보 - BeanDefinition
* 스프링은 어떻게 이런 다양한 설정 형식을 지원하는가?
  그 중심에는 BeanDefinition이라는 추상화가 있다
* 역할과 구현을 개념적으로 나눈것!
  * xml을 읽어서 BeanDefinition을 만들면 된다.
  * 자바 코드를 읽어서 BeanDefinition을 만들면 된다.
  * 스프링 컨테이너는 자바 코드인지, XML인지 몰라도 된다. 오직 BeanDefinition만 알면 된다.
* BeanDefinition을 빈 설정 메타정보라 한다.
  * `@Bean, <bean>`은 각각 하나씩 메타 정보가 생성된다.
* 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.


## 웹 애플리케이션과 싱글톤
싱글톤 - 객체가 JVM안에 딱 하나만 있어야하는 패턴
* 스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다.
* 대부분의 스프링 애플리케이션은 웹 애플리케이션이다. 물론 웹이 아닌 애플리케이션 개발도 얼마든지 개발할 수 있다.
* 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.


## 싱글톤 패턴
* 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.
* 그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다. 
  * private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 한다.

참고로 싱글톤 패턴을 구현하는 방법은 여러가지 있다. 여기서 객체를 미리 생성해두는 가장 단순하고 안전한 방법을 선택했다.

**싱글톤 패턴 문제점**
* 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
* 의존관계상 클라이언트가 구체 클래스에 의존한다. -> DIP를 위반한다. 추상화에 의지해야지 구체에 의지하면 안된다
* 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
* 테스트하기 어렵다.
* 내부 속성을 변경, 초기화 하기 어렵다.
* private 생성자로 자식 클래스를 만들기 어렵다.
* 유연성이 떨어진다.
* 안티패턴으로 불리기도 한다.


## 싱글톤 컨테이너(스프링 컨테이너)
스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다.
지금까지 우리가 학습한 스프링 빈이 바로 싱글톤으로 관리되는 빈이다.

**싱글톤 컨테이너**
* 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도 객체 인스턴스를 싱글톤으로 관리한다.
    * 컨테이너는 객체를 하나만 생성해서 관리한다.
* 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.
* 스프링 컨테이너의 이런 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
  * 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.
  * DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.

참고로 스프링의 기본 빈 등록 방식은 싱글톤이지만 싱글톤 방식만 지원하는 것은 아니다.


## 싱글톤 방식의 주의점
* 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 
  객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 
  여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.
* 무상태(stateless)로 설계해야 한다!
  * 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  * 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  * 가급적 읽기만 가능해야 한다.
  * 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal등을 사용해야 한다.
* 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다!!
* 공유필드는 조심해야한다. 스프링 빈은 항상 무상태로 설계하자!


## @Configuration과 싱글톤
AppConfig를 보면  
memberService와 orderService에서 memberRepository()를 호출한다.  
이 메서드를 호출하면 new MemoryMemberRepository()를 호출한다.
 
결과적으로 각각 다른 2개의 MemoryMemberRepository가 생성되면서 싱글톤이 깨지는 것 처럼 보인다.  
스프링 컨테이너는 이 문제를 어떻게 해결할까?

확인해보면 memberRepository 인스턴스는 모두 같은 인스턴스가 공유되어 사용된다.
AppConfig의 자바 코드를 보면 분명히 각각 2번 new MemoryMemberRepository를 호출해서 다른 인스턴스가 생성되어야 하는데  
어떻게 된 일일까?

* @Configuration을 작성하지 않으면 @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않는다.
  * 스프링 컨텍스트에 해당 클래스가 빈 설정 정보를 포함하고있음을 알려주므로 싱글톤으로 관리되지 않는다.
  * memberRepository() 처럼 의존관계 주입이 필요해서 메서드를 직접 호출할 때 싱글톤을 보장하지 않는다.
* 크게 고민할것없이 스프링 설정 정보는 항상 @Configuration을 사용하자


## 컴포넌트 스캔과 의존관계 자동 주입 시작하기
* 지금까지 스프링 빈을 등록할 때는 자바 코드의 @Bean이나 XML의 <bean> 등을 통해서 설정 정보에 직접 등록할 스프링 빈을 나열했다.
* 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다.
* 또 의존관계도 자동으로 주입하는 @Autowired라는 기능도 제공한다.

### @Autowired
* 생성자에 @Autowired를 지정하면 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
* 이때 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다.
  * getBean(MemberRepository.class)와 동일하다고 이해하면 된다.
  * 더 자세한 내용은 뒤에서 설명한다.


### 탐색할 패키지의 시작 위치 지정
모든 자바 클래스를 다 컴포넌트 스캔하면 시간이 오래 걸린다.
그래서 꼭 필요한 위치부터 탐색하도록 시작 위치를 지정할 수 있다.

**권장하는 방법**
설정 정보 클래스의 위치를 프로젝트 최상단에 두는것. 스프링 부트에서 이방법을 기본으로 제공한다.

### 컴포넌트 스캔 기본 대상
컴포넌트 스캔은 @Component 뿐만 아니라 다음과 같은 내용도 추가로 대상에 포함한다.
* @Component
* @Controller
* @Service
* @Repository
* @Configuration

`참고: 애노테이션에는 상속관계라는 것이 없다. 
그래서 이렇게 애노테이션이 특정 애노테이션을 들고 있는것을 인식할 수 있는 것은 
자바 언어가 지원하는 기능은 아니고, 스프링이 지원하는 기능이다.`


## 중복 등록과 충돌
컴포넌트 스캔에서 같은 빈 이름을 등록하면 어떻게 될까?
다음 두가지 상황이 있다.
1. 자동 빈 등록 vs 자동 빈 등록
2. 수동 빈 등록 vs 자동 빈 등록

### 자동 빈 등록 vs 자동 빈 등록 
* 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 스프링은 오류를 발생시킨다.
  * `ConflictingBeanDefinitionException` 예외 발생

### 수동 빈 등록 vs 자동 빈 등록 
* 이경우 수동 빈 등록이 우선권을 가진다.(수동 빈이 자동 빈을 오버라이딩 해버린다.)



## 다양한 의존관계 주입 방법
* 생성자 주입 : 생성자 호출시점 딱 1번만 호출되는 것이 보장된다. **불변, 필수 의존관계에 사용**
  * 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입 된다.
  * **스프링은 크게 3가지 라이프 사이클이 있다. 처음에 스프링 컨테이너를 생성하고 스프링 빈을 생성한다. 그리고 의존관계를 주입한다.**
* 수정자 주입(setter 주입) : **선택, 변경** 가능성이 있는 의존관계에 사용
* 필드 주입
  * 코드가 간결하여 예전에 많이 쓰였지만 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있다.
  * DI 프레임워크가 없으면 아무것도 할 수 없다.
  * 사용하지말자!
    * 테스트코드나 @Configuration 같은 곳에서만 특별한 용도로 사용
* 일반 메서드 주입

















